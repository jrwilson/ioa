\documentclass[letterpaper]{article}

\usepackage{outline}

\begin{document}

\title{An I/O Automata Framework for Distributed System Programming}
\author{Justin R. Wilson \and Christopher D. Gill}
\date{}

\maketitle

\begin{abstract}
In an effort to be portable, system developers often favor existing architectures, languages, operating systems, and standard libraries.
The dominant abstraction in established computing technologies for concurrency and therefore distributed system development is threads.
Consequently, distributed system developers are locked into using threads and experience the difficulties of thread-based development including obscure race conditions, poor support for the semantics of distributed systems, and difficulties integrating software developed using different thread models.
Furthermore, the demand for portability and generality dismisses many of the techniques proposed in research that involve new programming languages, language extensions, or domain-specific solutions.
This paper presents a development framework based on the I/O automata formal model implemented in C++.
The I/O automata model is a proven technique for distributed system design because its semantics match those found in distributed systems.
With the framework, developers can reason about correctness directly from the program text using the I/O automata formalism.
The I/O  automata model also provides a common abstraction for concurrency which facilitates software integration and promotes reuse.
TODO:  What are we doing for evaluation?
%% Our ability to realize sophisticated distributed systems such as those in cyber-physical systems and pervasive computing is predicated on a solid model and implementation of asynchrony and concurrency.
%% Threads, the de facto standard in practice, are not a suitable foundation because 1) ad hoc communication among threads prohibits software reuse, 2) threads are difficult to treat formally and therefore \emph{very} difficult to treat informally, and 3) threads are ill-suited for the asynchronous semantics present in the systems we desire to build.
%% In this paper, we outline the semantics necessary for building sophisticated distributed systems and connect these to the I/O automata formal model.
%% We then describe an implementation of the I/O automata formal model and cover extensions to the model necessary for operating in a dynamic environment.
%% Finally, we conclude with an evaluation of our I/O automata framework.
\end{abstract}

\section{Introduction}

Advances in embedded systems and networking are paving the way for distributed systems of unprecedented sophistication.
Cyber-physical systems go beyond the traditional embedded system paradigm by explicitly modeling the dynamics of the physical system and communication network in the computational task.
The inclusion of wireless network interfaces in modern electronic devices is transforming our homes, offices, and hospitals into pervasive computing environments.
The interactions these systems have with the physical environment and its community of users require a degree of interoperability, configurability, adaptability, scalability, robustness, and security not found in existing systems.

One of the forces that prevents the development of any kind of sophisticated software system is accidental complexity~\cite{brooks_nsb}.
In the context of distributed systems, a major source of accidental complexity is a mismatch between the conceptual model of the system and the technology used to implement the system.
The mismatch between the conceptual model and implementation method introduces defects due to translation errors, slows rapid prototyping, and retards iterative refinement.
While there is no ``silver bullet''~\cite{brooks_nsb}, reducing the accidental complexity derived from the mismatch between concept and implementation will increase productivity and make new levels of sophistication possible with existing levels of effort.

Threads are the de facto implementation vehicle for most of computing including distributed systems.
Threads dominate because modern processors, programming languages, and operating systems were all developed to support the thread model.
Furthermore, the widespread availability of thread libraries makes them a natural choice for system development.
While threads dominate in practice, using threads to develop systems has a number of significant drawbacks.

First, ad hoc communication among threads prohibits software reuse.
To illustrate this problem consider the challenge of developing an application with a graphical user interface that also uses a multi-threaded middleware library.
Graphical user interfaces often use a single-threaded event-based design, e.g., X, Swing.
The system integrator must write glue code that bridges the single-threaded event-based semantics to multi-threaded semantics.
Bridging between two thread models is achievable, however, the systems we desire to build will rely on many libraries each with their own thread model.
The importance of a unified approach to concurrency becomes apparent when one considers bridging between different threading models, e.g., event-based, reactor, proactor, active objects, and their attributes, e.g., priority, thread-creation, blocking vs. non-blocking I/O.

Second, threads are difficult to treat formally and therefore \emph{very} difficult to treat informally.
The correctness of programs is reasoned about either formally as part of formal software design and verification and/or informally during the debugging process.
Since most programs will never be formally verified, the correctness of most programs hinges solely on the developers ability to reason about the program.
Based on the historical example of structured programming~\cite{goto_considered_harmful}, there is a strong correlation between what is ``easy'' in the formal arena and what is ``easy'' in the informal arena, especially when the implementation mimics the formal model, e.g., structured programming languages.
It is well known that a formal treatment of threads is difficult due to the arbitrary interleaving of critical sections and ability to define critical sections of arbitrary scope~\cite{lee_threads}.
Thus, the correctness of most multi-threaded programs hinges on the developer's ability to explore arbitrary interleavings of critical sections, i.e., model checking, in their head.

Third, threads are ill-suited for the asynchronous semantics present in the systems we desire to build.
The distributed systems we desire to build are asynchronous at both the device and network levels.
Embedded devices must respond to asynchronous events in the environment.
The interrupt-driven TinyOS operating system for wireless sensor network motes is an exemplar in this area.
The fundamental communication primitive in real-world distributed systems is asynchronous message passing.
Realizing asynchrony in a threaded program requires the use of signals (interrupts) and/or (a)synchronous I/O multiplexing.
Signals are primitive, rigid, and difficult to use correctly.
Synchronous I/O multiplexing, e.g., a select loop, is limited to operating system abstractions, e.g., file descriptors, and induces a reactive state machine structure that is difficult to understand and maintain.
Asynchronous I/O improves efficiency by avoiding the dispatching necessary to determine the I/O operation but are subject to the same limitations of shared-state thread-based programming.

Difficulties in developing asynchronous and concurrent software using threads has prompted a number of concurrent programming languages, e.g., Esterel, Erlang, Ptolemy, Autopipe, and language extensions, e.g., OpenMP, Cilk, Split-C.
Solutions that involve creating a new language or extending an existing language suffer from two main problems.
First, such solutions are often domain-specific and do not generalize to different applications, a necessity for heterogeneous distributed systems.
Furthermore, solutions not connected to a general-purpose formal model lack the important property that the complete system including the environment can be modeled as another component.
Second, such solutions often fail to become mainstream due to practical considerations.
For example, the combination of C and pthreads is much more popular than Erlang due to the popularity of C-like languages and C's connection with UNIX operating system.
Most language extensions are targeted at niche markets and therefore never standardized and implemented in mainstream compilers.

Thus, in order to build sophisticated distributed systems, we require a common semantics and model for building concurrent and asynchronous systems with straight-forward abstractions.
%% The model must be general to support the wide variety of devices and protocols necessary for cyber-physical and pervasive computing systems.
%% The model must facilitate the development of concurrent modules that can be reused.
%% The model must have a strong connection with a formal model to simplify the task of reasoning about individual components and complete systems.
%% The model must be implemented in such a way that it is easily approachable.
In section~\ref{system_model}, we expound upon the requirements of the model and connect the requirements with the I/O automata formal model.
Section~\ref{representation} describes how I/O automata are represented in our I/O automata framework.
In section~\ref{design}, we describe the design and implementation of our I/O automata framework.
Section~\ref{evaluation} provides an evaluation and discussion of our framework.
Section~\ref{related_work} contains an overview of related work and we offer our conclusions and thoughts for future work in section~\ref{conclusion}.

%% We provide a common semantics and model for building concurrent and asynchronous systems with straight-forward abstractions.

%%formal models, e.g., UNITY, I/O Automata,

%% Devices are asynchronous and concurrent.
%% Networks are asynchronous and concurrent.
%% Why not start with a model that is asynchronous and concurrent?

%% What inspires us:
%% \begin{itemize}
%%   \item CORBA - Remote Method Invocation (Remote Procedure Call with a ``this'' pointer).
%%     ``Let's make synchronous function calls over a network.''
%%     Assumes a thread of control.
%%     Asynchronous calls were added later (Did these result in obfuscation?)

%%   \item Patterns for asynchronous concurrency in a synchronous, thread-based world: Active objects, Reactor, Proactor, etc.
%%     Examples: X server, OS2 Presentation Manager, Java Swing

%%   \item AJAX - The modern Web is built on JavaScript + \emph{asynchronous} web page requests = AJAX.

%%   \item Michi Henning - ICE

%%   \item Steve Vinoski - Toolbox of programming languages

%% \end{itemize}

%% We provide a common semantics and model for building concurrent and asynchronous systems with straight-forward abstractions.

\pagebreak

\section{System Model and Formalization\label{system_model}}

\subsection{Requirements}

Our system model is motivated by the semantics of devices, the semantics of distributed systems, and the desire for conceptual integrity.
We adopt a recursive view that nodes, i.e., devices, in a distributed system may themselves be represented as a distributed system consisting of different sensors, actuators, and processes.
We use the term \emph{node} to refer to a participant in a typical distributed system, i.e., one that uses standard network links.
We use term \emph{module} to refer to a computational element within a node.
Modules that reside on the same node are said to be \emph{collocated}.

\paragraph{Local State.}
We require that all modules and by extension all nodes only manipulate local state.
Said another way, there is no global or shared state.
Computation designed around the manipulation of local state only is easily modularized and consequently, easier to distribute and execute concurrently.

%% \paragraph{Message Passing.}
%% Nodes in distributed systems interact by passing messages over communication links.
%% Message passing can either be synchronous or asynchronous.
%% In synchronous message passing, the events of message production and delivery are the same, i.e., atomic.
%% In asynchronous message passing, the events of message production and delivery are logically distinct events subject to being interposed by other events.
%% Synchronous message passing is most often used between modules on the same node while asynchronous message passing is most often used between nodes.
%% Both synchronous and asynchronous message passing are required.
%% Synchronous message passing is necessary for building composable systems because of it association with atomicity.
%% Asynchronous message passing is necessary for building real distributed systems as this matches the semantics of the networks found in practice.

\paragraph{Asynchronous Atomic Events.}
Events are natural way to deal with the asynchrony involved in receiving messages from the network or interacting with the physical environment.
This implies that the model contains a general treatment of events, i.e., modules can both produce and consume events.
Modules, therefore, are reactive and structured as a set of atomic event produces and consumers.
The guarantee of atomicity obviates the need for concurrency control primitives and improves our ability to reason about the behavior of the module.
Modules communicate using events according to a \emph{configuration} that determines which events are delivered to each module.

%% Communicating with external resources such as the operating system or physical environment is foundational to writing useful programs.
%% Consider the history of I/O in the C run-time library.
%% The synchronous function call semantics of the C programming language made it possible to write system calls, e.g., read and write, that transfer control to the operating system which then completes the operation and return control to the process after the system call.
%% This is called \emph{blocking I/O} because the process blocks while it waits for the operating system to complete the I/O.
%% Blocking I/O has the severe restriction that only one I/O source can be used at a time.
%% To remedy this, system calls such as select and poll were introduced that allow a process to monitor I/O sources for events and then respond to these events.
%% Asynchronous I/O was a further advancement that allows for the system (instead of the process) to dispatch a function upon the completion of I/O.
%% Compare this to UNIX signals that are neither general (fixed-number with no associated data) nor principled.
%% Interrupts are difficult to use correctly.

\paragraph{Dynamics.}
The set of nodes and communication links is dynamic in real distributed systems.
Similarly, the set of modules and their configuration in real devices can change as the device may be re-purposed by users over time.
In general, our system model must support a dynamic number of modules and, consequently, dynamic configuration of those modules.

\paragraph{Reflection.}
The ability to dynamically configure a module implies that a module must be able to know its configuration status to preserve certain properties.
For example, consider a module for a reliable FIFO queue.
Since the queue can be dynamically configured, the queue must be able to determine if the event produced by removing and returning an item from the queue will be delivered.
Otherwise, the queue will lose data items and therefore not be reliable.

\subsection{I/O Automata}

The Input/Output (I/O) automata formal model developed by Lynch~\cite{distributed_algorithms} meets our requirements for local state and atomic asynchronous events.
An I/O automaton consists of state variables and atomic actions that manipulate the state.
The three action types are inputs, outputs, and internal actions.
Input actions receive a signal or a value and output actions produce a signal or a value.
Internal actions just manipulate the state of the automaton.
Output and internal actions are \emph{locally controlled actions}~\cite{distributed_algorithms} consisting of a precondition and an effect.
Input and output actions are \emph{external actions}~\cite{distributed_algorithms} because they allow an automaton to communicate with other automata.
Automata may \emph{composed} by concatenating the state variables of the constituent automata and incorporating the effects of input actions into output actions with the same name.
A useful operation in composite automata is \emph{hiding} which converts an output action to an internal action.
Composing automata results in a static configuration, i.e., the set of automata and their interactions are fixed.
Execution in the I/O automata model consists of repeatedly selecting a local action and then applying the effect if the precondition is true.
The scheduler is assumed to be fair meaning that a local action is guaranteed to be selected (but not executed) infinitely often.

\subsection{Extending I/O Automata for Dynamics}

A standard technique for modeling dynamic modules in I/O automata is to assume they exist but are inactive.
Dynamic automata can then be activated and deactivated using inputs.
This approach relies on the static configuration produced by composition and is therefore not suitable for an implementation.

We extend I/O automata for dynamic configuration by introducing a \emph{system automaton} that records the configuration of all automata in the system.
We differentiate between automaton types and automaton instances.
Every automaton instances has a unique \emph{automaton identifier (aid)}.
The state of the system automaton consists of the set of aids $A$ indicating what automata exist and a set of binding records $B$ indicating the relationship between output and input actions.
A binding record $(out, output, in, input)$ is tuple consisting of the aid of the output automaton $out$, the name of the output action $output$, the aid of the input automaton $in$, and the name of the input action $input$.

The configuration contained in set of binding records must be a valid static configuration to ensure that the behavior of the complete system remains analyzable under the I/O automata model.
TODO:  Output must exist.
TODO:  Input must exist.
TODO:  Binding must not exist.
First, an input can only be bound to one output.
Thus, a given $in$ and $input$ combination can appear at most once in $B$.
Second, an output cannot be bound to an input in the same automaton.
Thus, $out \neq in$ for every $(out, output, in, input)$ in $B$.
Third, an output cannot be bound to two inputs in the same automaton.
Thus, $in_1 \neq in_2$ for all $(out, output, in_1, input_1), (out, output, in_2, input_2)$ in $B$.

The system automaton contains input actions for creating an automaton, binding an output to an input, unbinding an output and an input, and destroying an automaton and output actions that indicate the result of a create, bind, unbind, or destroy.
All automata are composed with (not bound to) the system automaton and contain outputs for creating, binding, unbinding, and destroying and inputs for receiving results.
Systems calls (create, bind, unbind, destroy) resemble a request-response protocol where an automaton sends a request, the system automaton receives the request, the system automaton then sends the result, and the automaton receives the result.
This has the important consequence that \emph{configuration is asynchronous}.
Destroying an automaton has the effect of removing all of its bindings.
An automaton that destroys itself can therefore cause the system to deliver of unbound and destroyed events without a corresponding unbind or destroy.

\subsection{Extending I/O Automata for Reflection}

Automata are endowed with additional inputs driven by system outputs indicating when an action has been bound and unbound.
Automata might use the bound input to enable processing, i.e., someone is listening so I'll start producing data.
The unbound input is useful for cleaning data structures and inhibiting further processing, i.e., no one is listening so I'll stop producing data.
The bound and unbound inputs are useful but they are also asynchronous, thus, an automaton cannot trust the status reported by the last bound or unbound for use in, for example, a precondition.

The asynchronous nature of bound and unbound requires a primitive that can examine the contents of $B$ instantaneously.
Thus, we make one exception to the rule of local state that says automata can examine the contents of $B$ to determine their current configuration.
This is permissible so long as concurrent implementations provide multiple-reader/single-writer semantics to $B$.

\subsection{Equivalence}

Extending the I/O automata model for dynamics and reflection is useless unless we can relate the extensions back to the original model or establish equivalence.
To do this, we will take advantage of the fair traces (?) property of I/O automata~\cite{distributed_algorithms}.
%% We accept an execution trace in the dynamic setting if it is a fair trace of the static model.

%% Modeling a system with I/O automata implies a fixed set of automata given by $A_0$ and set of binding records $B_0$.

Start with a trace of dynamic $T_d$.
Remove system actions from $T_d$ so $T_d'$.
We accept $T_d'$ if it is a fair trace of the static model.

Let $A_0$ be the set of automata and $B_0$ be the set of binding records in the static model.
If you want to prove correspondence, you must prove that eventually $A = A_0$ and $B = B_0$.
We also need to show that no output is executed before it is fully bound.

%% supports the actions of creating an automaton, binding an output to an input, unbinding an output and an input, and destroying an automaton.
%% Upon creation, All automata are bound
%% The four operations necessary for dynamic configuration are \emph{create}, \emph{bind}, \emph{unbind}, and \emph{destroy}.

%% \begin{outline}
%% \item State
%%   \begin{outline}
%%   \item There is no shared state in a 
%%   \item Local state only
%%   \item Shared state
%%     \begin{outline}
%%       \item Impossible in distributed systems
%%       \item Dangerous in local systems
%%     \end{outline}
%%   \end{outline}
%% \item Communication
%%   \begin{outline}
%%   \item Atomic asynchronous message passing
%%   \item Network sets size of atom (UDP)
%%   \item Can build reliable streams (TCP)
%%   \item Local equivalent is passing a value
%%   \item Model should lend itself to writing protocols
%%   \end{outline}
%% \item Asynchrony
%%   \begin{outline}
%%     \item Model must have natural support for asynchrony, i.e., event-based
%%     \item Leads to a more efficient implementation because changed state and enabled actions become obvious
%%   \end{outline}
%% \item Concurrency
%%   \begin{outline}
%%     \item Reason about systems using non-deterministic interleaving of atomic actions
%%     \item Model should admit implementations that execute concurrently
%%   \end{outline}
%% \item Dynamics
%%   \begin{outline}
%%     \item Configuration - Edges in graph of communicating components can change at run-time.
%%       \begin{outline}
%%       \item Already required in distributed settings
%%       \item Not addressed in formal models
%%       \end{outline}
%%     \item Extension - Nodes in graph of communicating components can change at run-time.
%%   \end{outline}
%%   \item Reflection
%% \end{outline}

%% I/O Automata
%% \begin{itemize}
%%   \item Compare with UNITY
%%   \item Compare with esterel
%%   \item Compare with pi calculus
%%   \item Compare with Ptolemy
%% \end{itemize}

\section{I/O Automata Representation and Programming Model\label{representation}}

Conclude with our recommendations for programming, highlight need for exploration.

\section{Design and Implementation\label{design}}

\begin{itemize}
  \item Problem
  \item Design forces
  \item Solution
  \item Consequences
\end{itemize}

\section{Evaluation and Discussion\label{evaluation}}

\begin{itemize}
\item Translation of automaton in \emph{Distributed Algorithms} to C++.
\item Simulate a protocol then replace with network components
\item Compare a protocol using: single-threaded event-based (select loop), multi-threaded, I/O automata
\item Show a buggy program and then apply an invariant to find the bug.
\end{itemize}

Bring up style mentioned in section \ref{representation}.

\section{Related Work\label{related_work}}

pthreads (?)
Edward Lee - The Problem with Threads
Herb Sutter - The Free Lunch is Over
Early work on concurrency

\section{Conclusion and Future Work\label{conclusion}}

\begin{itemize}
  \item We are going to use it to build the substrate.
  \item Speculate on moving down into operating system (device drivers would be easy, IPC including filesystem replaced by automata)
  \item Speculate on moving down into the hardware level (Local talent, Ivan Sutherland)
  \item We can take advantage of multi-core in a very straight-forward way
  \item New problems in scheduling (Pinning automata to processors to minimize actions that span two processors.  Maximum independent set.)
  \item We are non-blocking all the way.  Combine this with a deterministic implementation of the scheduler and model and there are serious opportunities for real-time.
\end{itemize}

\end{document}
