\begin{abstract}
The ability to realize sophisticated distributed systems such as those found in cyber-physical systems, pervasive computing, and enterprise computing is predicated on a suitable model and implementation of asynchrony and concurrency.
The size and complexity of these systems implies that software re-use among their components is also essential.
Taken together, these requirements demand appropriate programming abstractions through which different forms of asynchrony and concurrency can be realized in reusable software.
% By different forms we meen single-threaded, multi-threaded, time triggered, event triggered, etc.

However, existing concurrency abstractions are inadequate to the needs of many sophisticated distributed systems, and new approaches are needed.
While threads match the semantics of widely available synchronous processors, thread-based development may introduce hazards for the distributed system developer including obscure race conditions, poor support for asynchrony, and difficulties integrating software developed using different thread models.
An alternative concurrency abstraction that matches the semantics of distributed systems and facilitates software re-use is therefore needed.

The reactive semantics I/O automata formal model match the asynchronous and concurrent semantics of distributed systems and the I/O automata formal model has been widely used in the design and verification of real distributed systems.
However, there is to date insufficient experience \emph{building} and evaluating real distributed systems directly atop I/O automata.
Previous efforts in this area have focused on formal software development, i.e., automata are described in a language suitable for theorem proving and simulation and aftward are translated into a production language for deployment.
The translation from modeling language to production language complicates interfacing with system facilities and makes developing low-level protocols difficult, an area which could greatly benefit from the direct application of I/O automata.

To this end, we contribute the \emph{ioa++ framework} for developing distributed systems.
In this paper, we outline a system model for distributed systems and connect these requirements to the I/O automata formal model.
We then describe how ioa++ is implemented in C++ and offer a number of examples showing how ioa++ can be used to develop distributed systems.

Our results \comment{experiences?} show that ioa++ can help simplify developing distributed systems.
Ioa++ allows developers to reason about asynchronous and concurrent programs directly from the source code using the I/O automata formal model.
Where reasoning about the correctness of a module in a threaded program requires considering interactions among the various threads, reasoning about the correctness of a module in ioa++ is limited to the module itself.
Common concurrency and interaction semantics allow simple modules to be aggregated into complex systems without building adapters that convert from one thread model to another.
\end{abstract}
