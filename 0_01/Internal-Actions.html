<html lang="en">
<head>
<title>Internal Actions - The I/O Automata Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The I/O Automata Library">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Tutorials.html#Tutorials" title="Tutorials">
<link rel="prev" href="Compiling-and-Linking.html#Compiling-and-Linking" title="Compiling and Linking">
<link rel="next" href="Creating-Automata.html#Creating-Automata" title="Creating Automata">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2011 Justin R. Wilson.

     This work is licensed under the Creative Commons
     Attribution-NoDerivs 3.0 Unported License. To view a copy of this
     license, visit http://creativecommons.org/licenses/by-nd/3.0/ or
     send a letter to Creative Commons, 444 Castro Street, Suite 900,
     Mountain View, California, 94041, USA.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Internal-Actions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Creating-Automata.html#Creating-Automata">Creating Automata</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Compiling-and-Linking.html#Compiling-and-Linking">Compiling and Linking</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Tutorials.html#Tutorials">Tutorials</a>
<hr>
</div>

<h3 class="section">2.2 Internal Actions</h3>

<p>In this tutorial we develop an automaton that counts to ten using an internal action. 
The source is given below and can be found in <samp><span class="file">tutorial/count_to_ten_automaton.cpp</span></samp>.

<pre class="example"><pre class="verbatim">     #include &lt;ioa/ioa.hpp>
     #include &lt;ioa/global_fifo_scheduler.hpp>
     
     // For std::cout.
     #include &lt;iostream>
     
     class count_to_ten_automaton :
       public ioa::automaton
     {
     private:
       int m_count;
     
     public:
       count_to_ten_automaton () :
         m_count (1)
       {
         schedule ();
       }
       
     private:
       void schedule () const {
         if (increment_precondition ()) {
           ioa::schedule (&amp;count_to_ten_automaton::increment);
         }
       }
     
       bool increment_precondition () const {
         return m_count &lt;= 10;
       }
     
       void increment_effect () {
         std::cout &lt;&lt; m_count &lt;&lt; std::endl;
         ++m_count;
       }
     
       UP_INTERNAL (count_to_ten_automaton, increment);
     };
     
     int main () {
       ioa::global_fifo_scheduler sched;
       ioa::run (sched, ioa::make_generator&lt;count_to_ten_automaton> ());
       return 0; 
     }
     
</pre></pre>
   <p>The automata in this tutorial are listed in a way that attempts to mimic the style in <cite>Distributed Algorithms</cite>. 
In general, an automaton will have the following structure:
     <ul>
<li>Type definitions &mdash; Declare types that are used internally by the automaton and types that are used by external actions.

     <li>State declarations &mdash; Declare the state variables of the automaton.

     <li>Constructors/Destructors &mdash; Declare/defined constructors to initialize the state variables and destructors to perform any required clean-up.

     <li><code>schedule</code> and other member functions &mdash; Declare/define the function for scheduling actions and other useful functions.

     <li>Actions &mdash; Declare/define the actions of the automaton.  Local actions consist of a precondition, a action body, and a member variable.  Input actions consist only of an action body.

   </ul>

   <p>Let's examine the automaton section by section. 
The state of the automaton is declared with
<pre class="example"><pre class="verbatim">     private:
       int m_count;
</pre>
</pre>
   <p>In this case, the state of the automaton consists of a single integer <code>m_count</code>. 
State variables should always be declared <code>private</code>.

   <p>The construction initializes the count to 1 and calls the <code>schedule ()</code> member function:
<pre class="example"><pre class="verbatim">     public:
       count_to_ten_automaton () :
         m_count (1)
       {
         schedule ();
       }
</pre>
</pre>
   <p>The <code>schedule ()</code> member function informs the scheduler what local actions to consider:
<pre class="example"><pre class="verbatim">     private:
       void schedule () const {
         if (increment_precondition ()) {
           ioa::schedule (&amp;count_to_ten_automaton::increment);
         }
       }
</pre>
</pre>
   <p>The <code>schedule ()</code> member function evaluates the precondition for the increment action and then schedules the increment action if the precondition is true. 
A common source of errors is to either omit a local action from the <code>schedule ()</code> function or forget to call <code>schedule ()</code> in a constructor. 
As an exercise, comment out the call to <code>schedule ()</code> in the constructor and see what happens. 
The <code>schedule ()</code> member function should always be declared <code>private</code>.

   <p>The next section defines the precondition and effect for an unparameterized internal action named <code>increment</code>:
<pre class="example"><pre class="verbatim">       bool increment_precondition () const {
         return m_count &lt;= 10;
       }
     
       void increment_effect () {
         std::cout &lt;&lt; m_count &lt;&lt; std::endl;
         ++m_count;
       }
</pre>
</pre>
   <p>Parameters and parameterized actions are discussed in (TODO). 
Following the style in <cite>Distributed Algorithms</cite>, internal actions are divided into a <dfn>precondition</dfn> and <dfn>effect</dfn>. 
The precondition returns a <code>bool</code> indicating if the action can be executed. 
In this example, the precondition returns true so long as the count is less than or equal to ten. 
The pattern for declaring the precondition for an unparameterized internal actions is <code>bool </code><var>action-name</var><code>_precondition () const;</code>. 
Note that preconditions have the <code>const</code> modifier as they should not change the state of the automaton. 
The effect changes the state of the automaton. 
In this example, the effect prints the current value of the count and increments the count. 
The pattern for declaring the effect of an unparameterized internal action is <code>void </code><var>action-name</var><code>_effect ();</code>. 
Preconditions and effects should be declared <code>private</code>.

   <p>The final part of declaring/defining an unparameterized internal action is to declare a member variable representing the action that dispatches to the precondition and effect and also contains appropriate typedefs for the scheduler. 
This is tedious so a set of a macros is defined to simplify declaring the members. 
The code
<pre class="example"><pre class="verbatim">       UP_INTERNAL (count_to_ten_automaton, increment);
</pre>
</pre>
   <p>uses the <code>UP_INTERNAL</code> macro to declare an action member variable <code>increment</code>. 
The <code>UP_INTERNAL</code> macro and similar macros rely on the <code>*_precondition</code> and <code>*_action</code> naming convention described earlier. 
The macros also require that the <code>schedule ()</code> member function be declared before the macro and has the signature <code>void schedule () const</code>. 
The macro arranges for the <code>schedule () </code> member function to be called after each action effect. 
This frees the programmer from remembering to call schedule in every action effect. 
Internal actions, i.e., the scope where <code>UP_INTERNAL</code> appears, should be <code>private</code>. 
External actions can either be <code>private</code>, <code>protected</code>, or <code>public</code> depending on their intended use.

   <p>To summarize, consider the uses of the automaton name and action names. 
To declare an automaton:
<pre class="example">     <code>class </code><var>automaton-name</var><code> : public ioa::automaton ...</code>
</pre>
   <p>To declare a precondition for an unparameterized internal action:
<pre class="example">     <code>bool </code><var>action-name</var><code>_precondition () const;</code>
</pre>
   <p>To declare a effect for an unparameterized internal action:
<pre class="example">     <code>void </code><var>action-name</var><code>_effect ();</code>
</pre>
   <p>To declare an unparameterized internal action:
<pre class="example">     <code>UP_INTERNAL (</code><var>automaton-name</var><code>, </code><var>action-name</var><code>);</code>
</pre>
   <p>To schedule an unparameterized local action:
<pre class="example">     <code>ioa::schedule (&amp;</code><var>automaton-name</var><code>::</code><var>action-name</var><code>);</code>
</pre>
   </body></html>

