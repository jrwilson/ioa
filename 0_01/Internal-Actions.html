<html lang="en">
<head>
<title>Internal Actions - IOA++</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="IOA++">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Examples.html#Examples" title="Examples">
<link rel="prev" href="Compiling-and-Linking.html#Compiling-and-Linking" title="Compiling and Linking">
<link rel="next" href="Creating-Automata.html#Creating-Automata" title="Creating Automata">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2011 Justin R. Wilson.

     This work is licensed under the Creative Commons
     Attribution-NoDerivs 3.0 Unported License. To view a copy of this
     license, visit http://creativecommons.org/licenses/by-nd/3.0/ or
     send a letter to Creative Commons, 444 Castro Street, Suite 900,
     Mountain View, California, 94041, USA.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Internal-Actions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Creating-Automata.html#Creating-Automata">Creating Automata</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Compiling-and-Linking.html#Compiling-and-Linking">Compiling and Linking</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Examples.html#Examples">Examples</a>
<hr>
</div>

<h3 class="section">3.2 Internal Actions</h3>

<p>In this tutorial we develop an automaton that counts to ten using an internal action. 
The source is given below and can be found in <samp><span class="file">tutorial/count_to_ten_automaton.cpp</span></samp>.

<pre class="example"><pre class="verbatim">     #include &lt;ioa/ioa.hpp>
     #include &lt;ioa/global_fifo_scheduler.hpp>
     
     // For std::cout.
     #include &lt;iostream>
     
     class count_to_ten_automaton :
       public ioa::automaton
     {
     private:
       int m_count;
     
     public:
       count_to_ten_automaton () :
         m_count (1) {
         increment_schedule ();
       }
       
     private:
       bool increment_precondition () const {
         return m_count &lt;= 10;
       }
     
       void increment_effect () {
         std::cout &lt;&lt; m_count &lt;&lt; std::endl;
         ++m_count;
       }
     
       void increment_schedule () const {
         if (increment_precondition ()) {
           ioa::schedule (&amp;count_to_ten_automaton::increment);
         }
       }
     
       UP_INTERNAL (count_to_ten_automaton, increment);
     };
     
     int main () {
       ioa::global_fifo_scheduler sched;
       ioa::run (sched, ioa::make_generator&lt;count_to_ten_automaton> ());
       return 0; 
     }
</pre></pre>
   <p>The automata in this tutorial are listed in a way that attempts to mimic the style in <cite>Distributed Algorithms</cite>. 
In general, an automaton will have the following structure:
     <ul>
<li>Type definitions &mdash; Declare types that are used internally by the automaton and types that are used by external actions.

     <li>State declarations &mdash; Declare the state variables of the automaton.

     <li>Constructors/Destructors &mdash; Declare/define constructors to initialize the state variables and destructors to perform any required clean-up.

     <li>Private member functions &mdash; Declare/define useful functions.

     <li>Actions &mdash; Declare/define the actions of the automaton.  Local actions consist of a precondition, an effect, a scheduling function, and a member variable.  Input actions consist of an effect, a scheduling function, and a member variable.

   </ul>

   <p>Let's examine the automaton section by section. 
The state of the automaton is declared with
<pre class="example"><pre class="verbatim">     private:
       int m_count;
</pre>
</pre>
   <p>In this case, the state of the automaton consists of a single integer <code>m_count</code>. 
State variables should always be declared <code>private</code>.

   <p>The constructor initializes the count to 1 and calls the <code>increment_schedule</code> member function to tell the scheduler to select the <code>increment</code> action:
<pre class="example"><pre class="verbatim">     public:
       count_to_ten_automaton () :
         m_count (1) {
         increment_schedule ();
       }
</pre>
</pre>
   <p>The next section defines the precondition, effect, and scheduling function for an unparameterized internal action named <code>increment</code>:
<pre class="example"><pre class="verbatim">       bool increment_precondition () const {
         return m_count &lt;= 10;
       }
     
       void increment_effect () {
         std::cout &lt;&lt; m_count &lt;&lt; std::endl;
         ++m_count;
       }
     
       void increment_schedule () const {
         if (increment_precondition ()) {
           ioa::schedule (&amp;count_to_ten_automaton::increment);
         }
       }
</pre>
</pre>
   <p>Following the style in <cite>Distributed Algorithms</cite>, internal actions are divided into a <dfn>precondition</dfn> and <dfn>effect</dfn>. 
The precondition returns a <code>bool</code> indicating if the action can be executed. 
In this example, the precondition returns true so long as the count is less than or equal to ten. 
The pattern for declaring the precondition for an unparameterized internal actions is <code>bool </code><var>action-name</var><code>_precondition () const;</code>. 
Note that preconditions have the <code>const</code> modifier as they should not change the state of the automaton. 
The effect changes the state of the automaton. 
In this example, the effect prints the current value of the count and increments the count. 
The pattern for declaring the effect of an unparameterized internal action is <code>void </code><var>action-name</var><code>_effect ();</code>. 
The scheduling function is called after the effect and it used to tell the scheduler about actions that should be selected. 
In this example, the <code>increment</code> action is scheduled if its precondition is true. 
The pattern for declaring a scheduling fuctions is <code>void </code><var>action-name</var><code>_schedule () const;</code>. 
Preconditions, effects, and scheduling functions should always be declared <code>private</code>.

   <p>The final part of declaring/defining an unparameterized internal action is to declare a member variable representing the action that dispatches to the precondition, effect, and scheduling function and also contains appropriate typedefs for the scheduler. 
This is tedious so a set of a macros is defined to simplify declaring the members. 
The code
<pre class="example"><pre class="verbatim">       UP_INTERNAL (count_to_ten_automaton, increment);
</pre>
</pre>
   <p>uses the <code>UP_INTERNAL</code> macro to declare an action member variable <code>increment</code>. 
The <code>UP_INTERNAL</code> macro and similar macros rely on the <code>*_precondition</code>, <code>*_action</code>, and <code>*_schedule</code> naming convention described earlier. 
The macro arranges for the <code>*_schedule</code> member function to be called after each action effect. 
Internal actions, i.e., the scope where <code>UP_INTERNAL</code> appears, should be <code>private</code>. 
External actions can either be <code>private</code>, <code>protected</code>, or <code>public</code> depending on their intended use.

   <p>To summarize, consider the uses of the automaton name and action names. 
To declare an automaton:
<pre class="example">     <code>class </code><var>automaton-name</var><code> : public ioa::automaton ...</code>
</pre>
   <p>To declare a precondition for an unparameterized internal action:
<pre class="example">     <code>bool </code><var>action-name</var><code>_precondition () const;</code>
</pre>
   <p>To declare a effect for an unparameterized internal action:
<pre class="example">     <code>void </code><var>action-name</var><code>_effect ();</code>
</pre>
   <p>To declare a scheduling function:
<pre class="example">     <code>void </code><var>action-name</var><code>_schedule () const;</code>
</pre>
   <p>To declare an unparameterized internal action:
<pre class="example">     <code>UP_INTERNAL (</code><var>automaton-name</var><code>, </code><var>action-name</var><code>);</code>
</pre>
   <p>To schedule an unparameterized local action:
<pre class="example">     <code>ioa::schedule (&amp;</code><var>automaton-name</var><code>::</code><var>action-name</var><code>);</code>
</pre>
   <p><strong>Programming Tip:</strong>
Forgetting to schedule is common source of problems when programming with IOA++. 
Remember to call <code>ioa::schedule</code> for all enabled local actions in the constructor and scheduling functions (or effects). 
As an exercise, experiment with commenting out the call to <code>increment_schedule</code> in the constructor and the call to <code>ioa::schedule</code> in <code>increment_schedule</code>.

   </body></html>

