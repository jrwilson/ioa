<html lang="en">
<head>
<title>Introduction - ioa++</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="ioa++">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="index.html#Top" title="Top">
<link rel="next" href="Examples.html#Examples" title="Examples">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual is for ioa++, version 0.01.

Copyright (C) 2011 Justin R. Wilson.

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing,
     software distributed under the License is distributed on an "AS
     IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
     express or implied.  See the License for the specific language
     governing permissions and limitations under the License.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Introduction"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Examples.html#Examples">Examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="index.html#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">1 Introduction</h2>

<p>ioa++ is a general-purpose framework for developing asynchronous and concurrent programs based on the I/O automata model. 
Developers using ioa++ construct programs by defining and assembling event-based modules called I/O automata to form interacting constellations. 
As suggested by the name, ioa++ is implemented in C++.

<h3 class="section">1.1 The I/O Automata Model</h3>

<p>The I/O automata model was developed by Nancy Lynch for asynchronous and concurrent systems and is described in Chapter 8 of <cite>Distributed Algorithms</cite>. 
I/O automata have been used to model and verify a number of real-world systems and protocols.

   <p>An I/O automaton consists of state variables and a set of atomic input, output, and internal actions. 
The set of actions in an automaton is known as its <dfn>signature</dfn>. 
Output and internal actions constitute the automaton's <dfn>local signature</dfn>. 
Local actions have a predicate over the state variables of the automaton (called a <dfn>precondition</dfn>) that indicates if the action can be executed. 
All actions have an <dfn>effect</dfn> which updates the state variables of the corresponding automaton. 
Input and output actions constitute the automaton's <dfn>external signature</dfn>.

   <p>I/O automata can be composed to form a new automaton by concatenating state variables and folding input actions into similarly named output actions. 
Whereas local actions can be <dfn>enabled</dfn> or <dfn>disabled</dfn> based on their precondition, input actions are executed whenever their associated output is executed. 
This property is known as being <dfn>input enabled</dfn>.

   <p>Execution proceeds by repeatedly selecting a local action and executing it if enabled. 
The model admits non-determinism by allowing the scheduler to pick actions in any order. 
Schedulers in I/O automata must be <dfn>fair</dfn> meaning they select (but do not necessarily execute) every action infinitely often.

<h3 class="section">1.2 Representing I/O Automata</h3>

<p>I/O automata are encoded directly in the C++ programming language as classes that inherit from <code>ioa::automaton</code>. 
The state variables of the I/O automaton are naturally encoded as member variables of the class. 
The actions of the I/O automaton are encoded as a combination of member functions and member variables. 
A suite of templates and macros exist to simplify the definition of actions.

<h3 class="section">1.3 Dynamics</h3>

<p>The I/O automata model assumes that systems consist of a static set of automata. 
Often, the size of the set is countably infinite meaning that it can be represented by an integer variable <var>N</var>. 
A model specified in this way is capable of capturing any real system since there is a countable number of participants in all real systems. 
Within an countably infinite set, a dynamic set of automata is simulated by associating a flag with each automaton indicating if it is active or inactive and defining appropriate &ldquo;wake-up&rdquo; and &ldquo;sleep&rdquo; actions. 
A direct implementation of this strategy does not work for real systems because an implementation must specify a concrete value for <var>N</var>. 
Computing with a fixed number of automata is either unduly prohibitive if resources exist for additional automata or unduly wasteful if the number of active automata is much less than <var>N</var>.

   <p>Consequently, we require the ability to dynamically create and destroy automata. 
An automaton that creates another automaton is called the <dfn>parent</dfn> while the created automaton is called the <dfn>child</dfn>. 
The automaton at the top of the hierarchy is called the <dfn>root</dfn>. 
Since we can dynamically create and destroy automata, we also require the ability to dynamically compose and decompose. 
<dfn>Binding</dfn> and <dfn>unbinding</dfn> refer to the act of dynamically composing and decomposing, respectively. 
For simplicity, binding and unbinding is limited to a single output action-input action pair. 
Explicit binding allows us to drop the requirement that the actions have the same name.

<h3 class="section">1.4 Run-time System</h3>

<p>The ioa++ run-time system consists of a system automaton, a dispatcher, a scheduler, and a user-space library.

   <p>The <dfn>system automaton</dfn> contains the set of automata and bindings that exist in the system and actions for creating, binding, unbinding, and destroying. 
These actions are collectively called <dfn>system actions</dfn>. 
Each automaton is <em>composed</em> with the system automaton by inheriting from <code>ioa::automaton</code>.

   <p>The <dfn>dispatcher</dfn> enforces atomic execution according to the I/O automata model. 
Internal actions are executed by evaluating the precondition and then applying the effect if the precondition is true. 
The precondition and effect are computed in one atomic step. 
Output actions are executed similarly except that all bound input actions are evaluated atomically with the output action.

   <p>The <dfn>scheduler</dfn> selects the next action from a set of local actions. 
The set of local actions is updated by the automata in the system via <code>ioa::schedule</code> calls. 
Different schedulers can be used to realize different scheduling policies.

   <p>The user-space library is designed to help users write actions, schedule actions, and request system actions. 
Local actions consist of an object and three functions: a precondition, an effect, and a scheduling function. 
Input actions consists of an object and two functions: an effect and a scheduling function. 
The scheduling function is invoked after the effect of all actions and is intended as a place to schedule actions. 
The user-space library also contains classes that hide the complexities of creating and binding asynchronously.

<h3 class="section">1.5 Concurrency</h3>

<p>Each local action involves a set of automata. 
For internal actions, this is just the automaton that contains the internal actions. 
For output actions, the set consists of the output action and the automata that contain the input actions bound to the output action. 
The semantics of I/O automata are such that two actions can be executed concurrently if their respective sets of involved automata are disjoint. 
An important consequence is that two actions belonging to the same automaton will never execute concurrently. 
True concurrent execution requires a scheduler capable of true concurrent execution, i.e., a multi-threaded scheduler.

<h3 class="section">1.6 Actions and Values</h3>

<p>Recall that there are three types of actions: output actions, input actions, and internal actions. 
Output actions produce a signal or value, input actions consume a signal or value, and internal actions neither produce nor consume signals or values. 
Actions that produce or consume signals are said to be <dfn>unvalued</dfn> while signals that produce and consume values are said to be <dfn>valued</dfn>. 
External actions can only be bound together if they agree on the signal or type of value to be produced. 
Any input that consumes a signal can be bound to any output producing a signal. 
An input that consumes values of type <var>T</var> can only be bound to an output that produces a value of type <var>T</var>.

<h3 class="section">1.7 Parameters and Automatic Parameters</h3>

<p>A common technique in the I/O automata model is to associate a parameter with an action. 
For example, actions that receive messages are often parameterized with communication endpoints. 
Parameters are distinct from values because they are constant under composition. 
All actions types, outputs, inputs, and internals, can be parameterized. 
Actions requiring a parameter are said to be <dfn>parameterized</dfn> while actions that don't require parameters are said to be <dfn>unparameterized</dfn>. 
Parameters must be used to identify parameterized actions. 
For example, the parameter for a parameterized output must specified when scheduling and binding. 
Similarly, a parameter for a parameterized input must specified when binding and a parameter for a parameterized internal must be specified when scheduling.

   <p>Parameters allow users to implement fan-in by associating a different parameter with each bind to an input. 
More generally, parameters can be used to implement a session by associating the same parameter with all bindings related to some automaton. 
Each automaton has a unique identifier called an <dfn>automaton identfier</dfn> or <dfn>aid</dfn>. 
Often, the parameter for a session is the aid of another automaton. 
To prevent errors and make sessions easier to implement, we introduce the concept of an automatic parameter. 
An <dfn>automatic parameter</dfn> or <dfn>auto parameter</dfn> is a parameter that represents the automaton on the opposite side of a binding. 
For example, an auto parameterized input bears the identifier of the output automaton to which it is bound. 
An auto parameterized output bears the identifier of the input automaton to which it is bound. 
According to the binding rules below, auto parameterized outputs can only be bound once.

<h3 class="section">1.8 Binding Rules</h3>

<p>To enforce the semantics of I/O automata, certain attempts to bind will fail. 
The automaton requesting a binding is called the <dfn>owner</dfn>. 
A binding is a tuple (output automaton, output action, output parameter, input automaton, input action, input parameter, owner). 
Unparameterized actions have a null parameter. 
A binding will fail if any of the following conditions is true:
     <ol type=1 start=1>
<li>The owner does not exist. 
<li>The output automaton does not exist. 
<li>The input automaton does not exist. 
<li>The binding already exists.  (This is only reported to the owner.) 
<li>The (input automaton, input action, input parameter) is already bound. 
<li>The (output automaton, output action, output parameter) is already bound to some input action in the input automaton. 
<li>The output automaton and input automaton are the same.
        </ol>

   </body></html>

