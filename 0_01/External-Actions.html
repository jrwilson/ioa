<html lang="en">
<head>
<title>External Actions - IOA++</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="IOA++">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Examples.html#Examples" title="Examples">
<link rel="prev" href="Creating-Automata.html#Creating-Automata" title="Creating Automata">
<link rel="next" href="Fan_002dout-and-Binding-Count.html#Fan_002dout-and-Binding-Count" title="Fan-out and Binding Count">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2011 Justin R. Wilson.

     This work is licensed under the Creative Commons
     Attribution-NoDerivs 3.0 Unported License. To view a copy of this
     license, visit http://creativecommons.org/licenses/by-nd/3.0/ or
     send a letter to Creative Commons, 444 Castro Street, Suite 900,
     Mountain View, California, 94041, USA.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="External-Actions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Fan_002dout-and-Binding-Count.html#Fan_002dout-and-Binding-Count">Fan-out and Binding Count</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Creating-Automata.html#Creating-Automata">Creating Automata</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Examples.html#Examples">Examples</a>
<hr>
</div>

<h3 class="section">3.4 External Actions</h3>

<p>In this tutorial, we introduce input and output actions and the concept of binding using a simple producer-consumer problem. 
We split the <code>count_to_ten_automaton</code> in previous tutorials into an automaton that produces numbers and another automaton that prints numbers. 
The source is given below and can be found in <samp><span class="file">tutorial/producer_consumer.cpp</span></samp>.

<pre class="example"><pre class="verbatim">     #include &lt;ioa/ioa.hpp>
     #include &lt;ioa/global_fifo_scheduler.hpp>
     
     #include &lt;iostream>
     
     class producer_automaton :
       public ioa::automaton
     {
     private:
       int m_count;
     
     public:
       producer_automaton () :
         m_count (1) {
         produce_schedule ();
       }
       
     private:
       bool produce_precondition () const {
         return m_count &lt;= 10;
       }
     
       int produce_effect () {
         int retval = m_count++;
         std::cout &lt;&lt; "producing " &lt;&lt; retval &lt;&lt; std::endl;
         return retval;
       }
     
       void produce_schedule () const {
         if (produce_precondition ()) {
           ioa::schedule (&amp;producer_automaton::produce);
         }
       }
     
     public:
       V_UP_OUTPUT (producer_automaton, produce, int);
     };
     
     class consumer_automaton :
       public ioa::automaton
     {
     private:
       void consume_effect (const int&amp; val) {
         std::cout &lt;&lt; "consuming " &lt;&lt; val &lt;&lt; std::endl;
       }
     
       void consume_schedule () const { }
     
     public:
       V_UP_INPUT (consumer_automaton, consume, int);
     };
     
     class producer_consumer_automaton :
       public ioa::automaton
     {
     public:
       producer_consumer_automaton () {
         ioa::automaton_manager&lt;producer_automaton>* producer =
           ioa::make_automaton_manager (this,
     	  ioa::make_generator&lt;producer_automaton> ());
     
         ioa::automaton_manager&lt;consumer_automaton>* consumer =
           ioa::make_automaton_manager (this,
               ioa::make_generator&lt;consumer_automaton> ());
     
         ioa::make_binding_manager (this,
     			       producer, &amp;producer_automaton::produce,
     			       consumer, &amp;consumer_automaton::consume);
       }
     
     };
     
     int main () {
       ioa::global_fifo_scheduler sched;
       ioa::run (sched, ioa::make_generator&lt;producer_consumer_automaton> ());
       return 0; 
     }
     
</pre></pre>
   <p>The first part of the <code>producer_automaton</code> resembles the <code>count_to_ten_automaton</code> in previous tutorials where we have renamed the <code>increment</code> action to <code>produce</code>. 
Of interest in this tutorial is <code>produce_effect</code> and the declaration of the <code>produce</code> output action:
<pre class="example"><pre class="verbatim">       int produce_effect () {
         int retval = m_count++;
         std::cout &lt;&lt; "producing " &lt;&lt; retval &lt;&lt; std::endl;
         return retval;
       }
     
     public:
       V_UP_OUTPUT (producer_automaton, produce, int);
</pre>
</pre>
   <p>The <code>produce_effect</code> increments the counter and returns the old value of the counter. 
The macro <code>V_UP_OUTPUT</code> declares a valued unparameterized output action named <code>produce</code> that produces a value of type <code>int</code>. 
The <code>V_UP_OUTPUT</code> macro relies on the same naming conventions as the <code>UP_INTERNAL</code> action seen in preceding tutorials. 
As an exercise, make the type given to <code>V_UP_OUTPUT</code> different from the type returned by <code>produce_effect</code>, e.g., change <code>int</code> to <code>float</code>, and recompile. 
Note that <code>V_UP_OUTPUT</code> appears in a <code>public</code> section. 
This is necessary because we want to allow other automata to bind to this action.

   <p>The <code>consumer_automaton</code> is quite simple and only contains a single valued unparameterized input action:
<pre class="example"><pre class="verbatim">       void consume_effect (const int&amp; val) {
         std::cout &lt;&lt; "consuming " &lt;&lt; val &lt;&lt; std::endl;
       }
     
       void consume_schedule () const { }
     
     public:
       V_UP_INPUT (consumer_automaton, consume, int);
</pre>
</pre>
   <p>Recall that I/O automata are input enabled so there is no <code>consume_precondition</code>. 
The macro <code>V_UP_INPUT</code> declares a valued unparameterized input action named <code>consume</code> that takes a value of type <code>int</code>. 
The <code>V_UP_INPUT</code> macro relies on the same naming conventions as the other macros. 
The effect used by <code>V_UP_INPUT</code> must take a single argument declared as a constant reference. 
Compare this with <code>consume_effect</code>. 
Again, note that <code>V_UP_INPUT</code> appears in a <code>public</code> section so we can bind to it.

   <p>The <code>consume_schedule</code> function is required even though it is empty. 
As an exercise, comment out the <code>consume_schedule</code> function and recompile to become familiar with the compilation error caused by omitting it.

   <p>The constructor of the <code>producer_consumer_automaton</code> creates a <code>producer_automaton</code> and a <code>consumer_automaton</code> and then binds the <code>produce</code> and <code>consume</code> actions of the respective automatons together:
<pre class="example"><pre class="verbatim">       producer_consumer_automaton () {
         ioa::automaton_manager&lt;producer_automaton>* producer =
           ioa::make_automaton_manager (this,
     	  ioa::make_generator&lt;producer_automaton> ());
     
         ioa::automaton_manager&lt;consumer_automaton>* consumer =
           ioa::make_automaton_manager (this,
               ioa::make_generator&lt;consumer_automaton> ());
     
         ioa::make_binding_manager (this,
     			       producer, &amp;producer_automaton::produce,
     			       consumer, &amp;consumer_automaton::consume);
       }
</pre>
</pre>
   <p>The child automata are created in the same way as in the preceding tutorials only we save the pointer to the new manager so we can pass it to the <code>ioa::make_binding_manager</code> function. 
This version of <code>ioa::make_binding_manager</code> takes a pointer to an <code>ioa::automaton</code> (see <a href="Creating-Automata.html#Creating-Automata">Creating Automata</a>), a pointer to an <code>ioa::automaton_handle_interface</code> for the output automaton, a pointer to a member for the output action, a pointer to an <code>ioa::automaton_handle_interface</code> for the input automaton, and a pointer to a member for the input action. 
The <code>ioa::automaton_handle_interface</code> is unimportant save to say that <code>ioa::automaton_manager</code> implements <code>ioa::automaton_handle_interface</code>. 
The <code>ioa;:make_binding_manager</code> function creates a new <code>ioa::binding_manager</code> that binds the output and input actions once the output and input automata have been created. 
Note that like automata creation, binding is asynchronous in IOA++.

<h4 class="subsection">3.4.1 Binding Rules</h4>

<p>There are a number of rules that must be observed when binding. 
The first set of rules are checked at compile time.
     <ol type=1 start=1>
<li>One Output, One Input &mdash; The first automaton/action pair must be an output and the second automaton/action pair must be an input.

     <li>Access &mdash; The output and input must be accessible from the scope where <code>ioa::make_binding_helper</code> is invoked.  For example, if automaton C is binding an output action in automaton O to an input action in automaton I, then both of the actions must be declared <code>public</code>.  As another example, if automaton C is binding one of its own output actions to an input in automaton I, then C can (and probably should) declare the output to be <code>private</code>.

     <li>Value Status Agreement &mdash; External actions need not produce/consume values.  External actions that don't produce/consume values are called <dfn>unvalued</dfn> while external action that do produce/consume values are called <dfn>valued</dfn>.  When binding, both the output and the input action must have the same value status.

     <li>Type Agreement &mdash; Valued external actions must agree on the same type.  For example, the <code>produce</code> action and <code>consume</code> action agree that the value being produced/consumed is an <code>int</code>.

        </ol>
The second set of rules are checked at run time.
     <ol type=1 start=1>
<li>An input action can only be bound to one output action. 
<li>An output action cannot be bound to two different inputs residing in the same automaton. 
<li>An output action cannot be bound to an input action in the same automaton.
        </ol>
These rules are necessary to adhere to the I/O automata model. 
Recall that automata are composed by matching the names of output and input actions. 
One could imagine a function that rewrites the names of all actions before composing. 
These rules say that such a function exists.

<h4 class="subsection">3.4.2 Binding Dynamics</h4>

<p>When I execute <code>producer_consumer</code>, I get the following output:
<pre class="example"><pre class="verbatim">     $ ./producer_consumer 
     producing 1
     producing 2
     producing 3
     producing 4
     producing 5
     producing 6
     producing 7
     consuming 7
     producing 8
     consuming 8
     producing 9
     consuming 9
     producing 10
     consuming 10
</pre>
</pre>
   <p>Recall that automata creation and binding is asynchronous. 
In this example, the producer was allowed to <code>produce</code> six times before <code>produce</code> was bound to <code>consume</code>. 
The <code>produce</code> action is a <dfn>lossy output</dfn> or an output whose values might be lost because no input is bound to receive them. 
We address this topic in the next tutorial.

   </body></html>

