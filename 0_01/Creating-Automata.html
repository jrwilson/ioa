<html lang="en">
<head>
<title>Creating Automata - IOA++</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="IOA++">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Examples.html#Examples" title="Examples">
<link rel="prev" href="Internal-Actions.html#Internal-Actions" title="Internal Actions">
<link rel="next" href="External-Actions.html#External-Actions" title="External Actions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2011 Justin R. Wilson.

     This work is licensed under the Creative Commons
     Attribution-NoDerivs 3.0 Unported License. To view a copy of this
     license, visit http://creativecommons.org/licenses/by-nd/3.0/ or
     send a letter to Creative Commons, 444 Castro Street, Suite 900,
     Mountain View, California, 94041, USA.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Creating-Automata"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="External-Actions.html#External-Actions">External Actions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Internal-Actions.html#Internal-Actions">Internal Actions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Examples.html#Examples">Examples</a>
<hr>
</div>

<h3 class="section">3.3 Creating Automata</h3>

<p>Decomposition is a powerful technique for managing complexity&mdash;especially in concurrent and distributed systems. 
Instead of solving the problem with one large automaton, we can decompose the problem into a number of simpler automata and bind their actions together. 
Additionally, decomposition also allows us to find generic components that can be reused for many problems.

   <p>In this tutorial we develop an automaton that creates two <code>count_to_ten_automaton</code>s. 
Binding actions will be covered later when we cover input and output actions. 
The source is given below and can be found in <samp><span class="file">tutorial/two_counters.cpp</span></samp>.

<pre class="example"><pre class="verbatim">     #include &lt;ioa/ioa.hpp>
     #include &lt;ioa/global_fifo_scheduler.hpp>
     
     #include &lt;iostream>
     
     class count_to_ten_automaton :
       public ioa::automaton
     {
     private:
       int m_count;
     
     public:
       count_to_ten_automaton () :
         m_count (1)
       {
         increment_schedule ();
       }
       
     private:
       bool increment_precondition () const {
         return m_count &lt;= 10;
       }
     
       void increment_effect () {
         std::cout &lt;&lt;
           "automaton: " &lt;&lt; ioa::get_aid () &lt;&lt;
           " count: " &lt;&lt; m_count &lt;&lt; std::endl;
         ++m_count;
       }
     
       void increment_schedule () const {
         if (increment_precondition ()) {
           ioa::schedule (&amp;count_to_ten_automaton::increment);
         }
       }
     
       UP_INTERNAL (count_to_ten_automaton, increment);
     };
     
     class two_counter_automaton :
       public ioa::automaton
     {
     public:
       two_counter_automaton () {
         ioa::make_automaton_manager (this,
             ioa::make_generator&lt;count_to_ten_automaton> ());
         ioa::make_automaton_manager (this,
     	ioa::make_generator&lt;count_to_ten_automaton> ());
       }
     
     };
     
     int main () {
       ioa::global_fifo_scheduler sched;
       ioa::run (sched, ioa::make_generator&lt;two_counter_automaton> ());
       return 0; 
     }
</pre></pre>
   <p>This example contains two automata: <code>count_to_ten_automaton</code> and <code>two_counter_automaton</code>. 
Of primary interest is the constructor of the <code>two_counter_automaton</code>.
<pre class="example"><pre class="verbatim">       two_counter_automaton () {
         ioa::make_automaton_manager (this,
             ioa::make_generator&lt;count_to_ten_automaton> ());
         ioa::make_automaton_manager (this,
     	ioa::make_generator&lt;count_to_ten_automaton> ());
       }
</pre>
</pre>
   <p>The function <code>ioa::make_automaton_manager</code> creates a dynamically allocated <code>ioa::automaton_manager</code>. 
An <code>ioa::automaton_manager</code> uses an <code>ioa::automaton</code> object and generator to <em>asynchronously</em> create a new automaton. 
<em>Automaton creation and destruction are asynchronous in IOA++.</em>
A pointer to an <code>ioa::automaton</code> object is specified by the first argument to the <code>ioa::make_automaton_manager</code> function. 
This should always be the <code>this</code> pointer of the automaton that is creating a new automaton. 
The second argument is a generator that returns an instance of the automaton to be created. 
In this example, each generator returns a <code>count_to_ten</code> automaton.

   <p>If automaton A creates automaton B then A is the <dfn>parent</dfn> of B and B is the <dfn>child</dfn> of A. 
Thus, automata in IOA++ form a tree with the automaton generated by <code>ioa::run</code> being the root. 
When an automaton is destroyed, so are all of its children.

   <p>Something that might concern you is that fact that the automaton managers are dynamically allocated but we neither save their address nor <code>delete</code> them in a destructor. 
Upon construction, the <code>ioa::automaton</code> object takes ownership of the automaton manager. 
A parent automaton can request that one of its children be destroyed using its <code>destroy</code> method and can detect child automata that have been destroyed by observing the automaton manager. 
Note that a child automaton might voluntarily destroy itself, i.e., self destruct, when it has no more work to do. 
A parent automaton should forget the automaton manager of any child that has been destroyed.

   <p>To distinguish the output of the two <code>count_to_ten_automaton</code>s, we use the <code>ioa::get_aid</code> function.
<pre class="example"><pre class="verbatim">         std::cout &lt;&lt;
           "automaton: " &lt;&lt; ioa::get_aid () &lt;&lt;
           " count: " &lt;&lt; m_count &lt;&lt; std::endl;
</pre>
</pre>
   <p>Associated with each instance of an automaton is an <dfn>automaton identifier (aid)</dfn> of type <code>aid_t</code> that can be retrieved with <code>ioa::get_aid</code>.

   </body></html>

